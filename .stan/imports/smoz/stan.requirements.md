# Project Requirements — @karmaniverous/smoz

When updated: 2025-10-16T00:00:00Z

Purpose

- This document captures durable, repo‑specific requirements for the SMOZ
  toolkit. It is the single source of truth for product/engineering policy.
- Assistant/policy instructions live in .stan/system/stan.project.md.

Contents

- 1) Repository scope and publishing
- 2) Architecture and application model
- 3) HTTP middleware policy (order and behavior)
- 4) Aggregation builders (Serverless + OpenAPI)
- 5) CLI — commands, dev loop, and local modes
- 6) Register freshness (Serverless plugin) and optional hooks
- 7) Templates — baseline, TypeScript configs, ESLint, and placeholders
- 8) Init UX — conflicts, installation, defaults, and manifest handling
- 9) Routing, path normalization, and portability
- 10) Event tokens and HTTP tokens
- 11) App‑level function defaults (env keys)
- 12) Types hygiene (reuse public platform types)
- 13) Lint/format and template scalability
- 14) Documentation structure and Typedoc ordering
- 15) Integration fixture (/app)
- 16) Install guard (operators may forget install)
- 17) Logger shape
- 18) OpenAPI specs (hand‑crafted)
- 19) Testability of environment config

---

## 1) Repository scope and publishing

- Publish only the toolkit and templates to npm:
  - files: ["dist", "templates"]
  - The /app fixture is not published; it is for CI validation only.
- Toolkit surface:
  - Runtime wrapper and HTTP middleware building blocks.
  - Serverless/OpenAPI aggregators and helpers.
  - Configuration typing and utilities (e.g., path helpers).
- Build & publish policy (bundling & path aliases):
  - Published outputs (ESM/CJS/DTS) MUST NOT contain project‑local TS alias
    specifiers (e.g., `@/src/...`). The Rollup build resolves `@/` → `src/`
    via @rollup/plugin‑alias so downstream runtimes never see alias specifiers.

## 2) Architecture and application model

Schema‑first App with a registry:

- App.create(config) captures:
  - Global/stage parameter schemas and env exposure nodes.
  - Event type map schema and runtime HTTP tokens.
  - Stage artifacts: provider environment, params, and a per‑function env builder.
  - Implementation‑wide Serverless defaults.
- Author endpoints as small modules:
  - lambda.ts (register + schemas)
  - handler.ts (business logic)
  - openapi.ts (operation)
  - serverless.ts (non‑HTTP extras)
- Registry APIs per function: handler(business), openapi(baseOperation), serverless(extras).
- Side‑effect registers (generated by CLI):
  - app/generated/register.functions.ts — imports all lambda.ts
  - app/generated/register.openapi.ts — imports all openapi.ts
  - app/generated/register.serverless.ts — imports non‑HTTP serverless.ts

## 3) HTTP middleware policy (order and behavior)

Canonical order (must remain stable):
1. HEAD short‑circuit (returns 200 {} immediately)
2. Header normalizer
3. APIGateway v1 event normalizer
4. Content negotiation (JSON + vendor +json)
5. JSON body parser (no 415 on missing content type)
6. Zod validation (before handler; after handler)
7. Error exposure (maps validation failures to 400)
8. http‑error‑handler (uses ConsoleLogger)
9. CORS (credentials on; preserves computed origin)
10. Preferred media defaults across phases
11. Response shaper (enforce Content‑Type; ensure string body)
12. Response serializer (JSON + vendor +json)

Acceptance:
- HEAD is finalized to 200 {} and is not post‑validated.
- Shaped/string bodies pass transparently; others are shaped.
- Zod validation failures map to 400; other errors are exposed per handler.

## 4) Aggregation builders

- buildAllServerlessFunctions():
  - For HTTP tokens: derive method/basePath/contexts (or infer from paths)
    and produce handler strings. Provider env comes from app; per‑function env
    is built from explicit fnEnvKeys excluding globally exposed keys.
  - For non‑HTTP tokens: pass through extras supplied via serverless(extras).
- buildAllOpenApiPaths():
  - Merge path items for each configured context. operationId is composed as
    `${segments}_${method}` with a context prefix for non‑public routes.

## 5) CLI — commands, dev loop, and local modes

Conventions:
- Author code under app/config/app.config.ts and app/functions/<eventType>/...
- Generated artifacts live under app/generated/ (register.*.ts, openapi.json).

Commands:
- smoz init — scaffold app files, seed empty registers, add serverless.ts and
  an OpenAPI build script; optionally install dependencies.
- smoz register — one‑shot; generate app/generated/register.functions.ts,
  register.openapi.ts, and register.serverless.ts; idempotent and formatted.
- smoz openapi — one‑shot; run the app’s OpenAPI builder.
- smoz dev — orchestrated watch loop:
  1) register (if enabled), 2) openapi (if enabled), 3) local serving
     (restart/refresh if applicable).

Dev loop flags (precedence: CLI > cliDefaults.dev > hard defaults):
- -r/--register | -R/--no-register (default: on)
- -o/--openapi | -O/--no-openapi (default: on)
- -l/--local [inline|offline|false] (default: inline when available)
- -s/--stage <name> (default: first non‑"default" stage; fallback "dev")
- -p/--port <n> (default: 0 → random free port)
- -V/--verbose

Source watch set:
- app/functions/**/{lambda.ts,openapi.ts,serverless.ts}
- Single debounced queue (~250 ms). Never run steps concurrently.
- Print “Updated” vs “No changes”.

Local modes (HTTP):
- offline (serverless‑offline): spawn serverless offline start; pre‑run
  register+openapi; restart child on route surface change; prefix child output.
- inline (default once implemented): in‑process server mapping Node HTTP →
  APIGatewayProxyEvent (v1) → wrapped handler. Build route table from
  app.buildAllServerlessFunctions(); wrapper handles HEAD, negotiation, errors.
  Print route table and resolved port.

Stage & environment in dev:
- Stage default: first stage key in app.stages not named "default"; fallback dev.
- Seed process.env from app.global.params and app.stage.params[stage] so dev
  mirrors provider env semantics.

## 6) Register freshness (Serverless plugin) and optional hooks

- Provide a lightweight Serverless v4 plugin
  (@karmaniverous/smoz/serverless‑plugin) that runs `smoz register` before
  package/deploy steps. Keep it small and fail fast.
- Optional pre‑commit recipe (documented, not enforced): run `smoz register`
  when app/functions/** changes and stage updated register.*.ts files.
- Continue chaining `register` ahead of scripts that depend on fresh registers:
  - openapi: register && tsx app/config/openapi && prettier
  - package/deploy: register && serverless ...

## 7) Templates — baseline, TypeScript configs, ESLint, and placeholders

Baseline:
- Single "default" template including:
  - app/config/app.config.ts
  - app/functions/rest/hello/get/{lambda,handler,openapi}.ts
  - app/functions/rest/openapi/get/{lambda,handler,openapi}.ts
  - serverless.ts
  - app/config/openapi.ts and scripts (register/openapi/package/dev)
- Non‑HTTP examples are added via `smoz add` or documented under /examples.

TypeScript configs (two‑tsconfig approach):
- Dev tsconfig (templates/default/tsconfig.json):
  - Maps @karmaniverous/smoz → ../../dist so editors and typed ESLint resolve
    the toolkit without publishing.
- Downstream tsconfig (templates/default/tsconfig.downstream.json) — shipped:
  - `smoz init` renames this to tsconfig.json (writes tsconfig.json.example if a
    tsconfig already exists).
  - Contains no repo‑local path mappings.
- Typed ESLint project (templates/default/tsconfig.eslint.json) — extend‑only:
  - Extends ./tsconfig.json so typed ESLint resolves types consistently.
  - Houses lint‑only tweaks without perturbing the compiler.

Template ESLint:
- A unified ESLint flat config (templates/default/eslint.config.ts) drives typed
  lint for template sources using tseslint with project ['./tsconfig.eslint.json'].

Template typecheck:
- Script discovers templates/*/tsconfig.json and runs `tsc -p --noEmit`.

Register placeholders policy:
- Templates must typecheck in a clean clone without running CLI steps. Ship a
  single ambient declarations file that declares:
  - '@/app/generated/register.functions'
  - '@/app/generated/register.openapi'
  - '@/app/generated/register.serverless'
- Runtime placeholders are created by `smoz init` in real apps and maintained by
  `smoz register`; templates should not include app/generated placeholders.

## 8) Init UX — conflicts, installation, defaults, and manifest handling

Template selection:
- -t/--template accepts a packaged template name ("default")
  or a filesystem directory path.

Conflict handling (non‑package.json files):
- Interactive: Overwrite, Add example (<file>.example), Skip. Provide “apply to all”.
- Non‑interactive (-y): governed by cliDefaults.init.onConflict (ask|overwrite|example|skip);
  default is "example"; --conflict overrides.

Installation:
- With -y: perform install by default using the detected PM (npm|pnpm|yarn|bun).
  Overrides: --no-install or --install <pm>.
- Without -y: prompt for install; in CI, use -y with an explicit --install.

Defaults file (optional): smoz.config.json may provide:
- cliDefaults.init.onConflict, cliDefaults.init.install, cliDefaults.init.template,
  and cliDefaults.dev.local.

Manifest handling:
- Do not copy the template’s package.json during init.
- Always handle the manifest via an additive merge:
  - Create when missing; otherwise merge dependencies/devDependencies/peerDependencies
    and scripts only when absent; never overwrite existing keys.
- Avoids unnecessary conflict prompts for package.json while keeping behavior predictable.

## 9) Routing, path normalization, and portability

- One function per method/basePath; HEAD is auto‑handled by the middleware
  (do not author duplicate HEAD routes).
- Multiple security contexts via httpContexts (public/private/my); non‑public
  paths receive a context prefix in Serverless and OpenAPI surfaces.
- Normalize all paths to POSIX separators in authored code and generated artifacts.
- Provide small helpers (toPosixPath, dirFromHere) for cross‑platform hygiene.

## 10) Event tokens and HTTP tokens

- The single source of truth for event tokens is baseEventTypeMapSchema
  (rest, http, sqs, ...). Extend it per project needs.
- defaultHttpEventTypeTokens establishes which tokens are treated as HTTP at runtime.
- Step Functions (Lambda Invoke) is a first‑class token:
  - Token: `step`
  - Zod v4 shape: `z.object({ Payload: z.unknown().optional() }).catchall(z.unknown())`
    (use catchall; passthrough is deprecated).

## 11) App‑level function defaults (env keys)

- App.create accepts optional `functionDefaults.fnEnvKeys`.
- Registry merges defaults and per‑function `fnEnvKeys`.
- Provider‑level environment is built from globally exposed keys; per‑function
  env includes only additional keys (excluding globals).

## 12) Types hygiene (reuse public platform types)

- Do not redeclare platform types that exist in public dependencies; import from
  aws‑lambda or toolkit contracts.
- Inline dev server (HTTP):
  - Use APIGatewayProxyEvent (v1), APIGatewayProxyResult, and Context from aws‑lambda.
  - Mapping: Node HTTP → APIGatewayProxyEvent (v1) → wrapped handler; pass the
    resulting envelope through.

## 13) Lint/format and template scalability

- Prettier is the single source of truth for formatting; ESLint defers to Prettier
  and enforces TypeScript/ordering rules.
- Keep imports sorted (simple‑import‑sort).
- A unified templates ESLint config enables typed lint for all templates without
  per‑template edits.
- Template typecheck script scales by discovering tsconfig.json under templates/*.

## 14) Documentation structure and Typedoc ordering

- External docs (docs‑src/*.md) include front matter (title, sidebar_label, sidebar_position).
- Typedoc ordering in typedoc.json "projectDocuments":
  1. Overview
  2. Why smoz?
  3. Getting started
  4. 10‑minute tour
  5. Middleware
  6. Recipes (index + subpages)
  7. Templates
  8. CLI
  9. Contributing
  10. CHANGELOG.md
- Exclude CLI source symbols (src/cli/**) from API reference; CLI usage is documented in docs‑src/cli.md.

## 15) Integration fixture (/app)

Purpose:
- Keep a small in‑tree example app to validate end‑to‑end flows in CI
  (register → OpenAPI → package). Not intended for deployment and not published.

Policy:
- Keep /app on main to avoid bitrot; do not move it to a long‑lived branch.
- Neutral identifiers:
  - service: smoz‑sample
  - domains: api.example.test / api.dev.example.test
  - ARNs: placeholders
- Provide /app/README.md explaining purpose and non‑publish status.
- Ensure repository scripts operate against the fixture without deploy (package only).

## 16) Install guard (operators may forget install)

- Detect and surface likely missing installs (no node_modules/ or common module‑not‑found logs for core dependencies).
- Prompt users to run their package manager’s install rather than adding shims.
- Remove accidental shims after install.

## 17) Logger shape

- Any accepted logger must satisfy ConsoleLogger (console‑compatible).
- Defaults use `console`; middleware and wrappers rely on ConsoleLogger.

## 18) OpenAPI specs (hand‑crafted)

- OpenAPI specs are authored by hand; no automatic derivation from Zod.
- When useful, use `z.any()` as placeholders and refine iteratively.

## 19) Testability of environment config

- Avoid top‑level ESM imports from config paths that complicate `vi.mock()`;
  prefer lazy imports inside functions to keep tests predictable.
- Avoid dynamic type imports.
