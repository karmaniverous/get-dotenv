# Project Requirements — @karmaniverous/smoz

When updated: 2025-11-25T00:00:00Z

Purpose

- This document captures durable, repo‑specific requirements for the SMOZ
  toolkit. It is the single source of truth for product/engineering policy.
- Assistant/policy instructions live in .stan/system/stan.project.md.

Contents

- 1. Repository scope and publishing
- 2. Architecture and application model
- 3. HTTP middleware policy (order and behavior)
- 4. Aggregation builders (Serverless + OpenAPI)
- 5. CLI — commands, dev loop, local modes, and DynamoDB local orchestration
- 6. Register freshness (Serverless plugin) and optional hooks
- 7. Templates — baseline, TypeScript configs, ESLint, placeholders, and dynamodb template
- 8. Init UX — conflicts, installation, defaults, and manifest handling
- 9. Routing, path normalization, and portability
- 10. Event tokens and HTTP tokens
- 11. App‑level function defaults (env keys)
- 12. Types hygiene (reuse public platform types)
- 13. Lint/format and template scalability
- 14. Documentation structure and Typedoc ordering
- 15. Integration fixture (/app)
- 16. Install guard (operators may forget install)
- 17. Logger shape
- 18. OpenAPI specs (hand‑crafted)
- 19. Testability of environment config
- 20. DynamoDB integration (versioned tables, dynamic naming, local orchestration, migrations)

---

## 1) Repository scope and publishing

- Publish only the toolkit and templates to npm:
  - files: ["dist", "templates"]
  - The /app fixture is not published; it is for CI validation only.
- Toolkit surface:
  - Runtime wrapper and HTTP middleware building blocks.
  - Serverless/OpenAPI aggregators and helpers.
  - Configuration typing and utilities (e.g., path helpers).
- Build & publish policy (bundling & path aliases):
  - Published outputs (ESM/CJS/DTS) MUST NOT contain project‑local TS alias
    specifiers (e.g., `@/src/...`). The Rollup build resolves `@/` → `src/`
    via @rollup/plugin‑alias so downstream runtimes never see alias specifiers.

## 2) Architecture and application model

Schema‑first App with a registry:

- App.create(config) captures:
  - Global/stage parameter schemas and env exposure nodes.
  - Event type map schema and runtime HTTP tokens.
  - Stage artifacts: provider environment, params, and a per‑function env builder.
  - Implementation‑wide Serverless defaults.
- Author endpoints as small modules:
  - lambda.ts (register + schemas)
  - handler.ts (business logic)
  - openapi.ts (operation)
  - serverless.ts (non‑HTTP extras)
- Registry APIs per function: handler(business), openapi(baseOperation), serverless(extras).
- Side‑effect registers (generated by CLI):
  - app/generated/register.functions.ts — imports all lambda.ts
  - app/generated/register.openapi.ts — imports all openapi.ts
  - app/generated/register.serverless.ts — imports non‑HTTP serverless.ts
- Cross‑cutting for DynamoDB apps:
  - Handlers may import an EntityClient + EntityManager directly to perform CRUD/search inline; request/response schemas must borrow from the authoritative domain Zod used by the EntityManager.

## 3) HTTP middleware policy (order and behavior)

Canonical order (must remain stable):

1. HEAD short‑circuit (returns 200 {} immediately)
2. Header normalizer
3. APIGateway v1 event normalizer
4. Content negotiation (JSON + vendor +json)
5. JSON body parser (no 415 on missing content type)
6. Zod validation (before handler; after handler)
7. Error exposure (maps validation failures to 400)
8. http‑error‑handler (uses ConsoleLogger)
9. CORS (credentials on; preserves computed origin)
10. Preferred media defaults across phases
11. Response shaper (enforce Content‑Type; ensure string body)
12. Response serializer (JSON + vendor +json)

Acceptance:

- HEAD is finalized to 200 {} and is not post‑validated.
- Shaped/string bodies pass transparently; others are shaped.
- Zod validation failures map to 400; other errors are exposed per handler.

## 4) Aggregation builders

- buildAllServerlessFunctions():
  - For HTTP tokens: derive method/basePath/contexts (or infer from paths)
    and produce handler strings. Provider env comes from app; per‑function env
    is built from explicit fnEnvKeys excluding globally exposed keys.
  - For non‑HTTP tokens: pass through extras supplied via serverless(extras).
- buildAllOpenApiPaths():
  - Merge path items for each configured context. operationId is composed as
    `${segments}_${method}` with a context prefix for non‑public routes.

## 5) CLI — commands, dev loop, local modes, and DynamoDB local orchestration

Conventions:

- Author code under app/config/app.config.ts and app/functions/<eventType>/...
- Generated artifacts live under app/generated/ (register.\*.ts, openapi.json).

Commands:

- smoz init — scaffold app files, seed empty registers, add serverless.ts and
  an OpenAPI build script; optionally install dependencies.
- smoz register — one‑shot; generate app/generated/register.functions.ts,
  register.openapi.ts, and register.serverless.ts; idempotent and formatted.
- smoz openapi — one‑shot; run the app’s OpenAPI builder.
- smoz dev — orchestrated watch loop:
  1. register (if enabled), 2) openapi (if enabled), 3) local serving
     (restart/refresh if applicable).
- DynamoDB CLI plugin (always included by SMOZ):
  - Table lifecycle: generate, validate, create, delete, purge, migrate (see §20 for deployment/migration policy).
  - Local orchestration:
    - smoz dynamodb local start [--port <n>]
      - Config‑first: run `plugins.dynamodb.local.start` and block until healthy.
      - Embedded fallback: if @karmaniverous/dynamodb-local is installed, run setupDynamoDbLocal(port) and wait for readiness; else print guidance.
    - smoz dynamodb local status
      - Config‑first: run `plugins.dynamodb.local.status` and pass through exit code (0 = healthy).
      - Embedded fallback: probe with SDK/library; else print guidance.
    - smoz dynamodb local stop
      - Config‑first: run `plugins.dynamodb.local.stop`; else embedded path; else guidance.
    - Endpoint derivation (printed on start):
      1. `plugins.dynamodb.local.endpoint`
      2. `plugins.dynamodb.local.port` → `http://localhost:{port}`
      3. `$DYNAMODB_LOCAL_ENDPOINT`
      4. Fallback `http://localhost:${DYNAMODB_LOCAL_PORT ?? '8000'}`
    - No separate “ready” command; start waits until healthy.
    - Environment variables are interpolated natively by get‑dotenv in config command strings (e.g., `$DYNAMODB_LOCAL_ENDPOINT`, `$DYNAMODB_LOCAL_PORT`).

Dev loop flags (precedence: CLI > cliDefaults.dev > hard defaults):

- -r/--register | -R/--no-register (default: on)
- -o/--openapi | -O/--no-openapi (default: on)
- -l/--local [inline|offline|false] (default: inline when available)
- -s/--stage <name> (default: first non‑"default" stage; fallback "dev")
- -p/--port <n> (default: 0 → random free port)
- -V/--verbose

Source watch set:

- app/functions/\*\*/{lambda.ts,openapi.ts,serverless.ts}
- Single debounced queue (~250 ms). Never run steps concurrently.
- Print “Updated” vs “No changes”.

Local modes (HTTP):

- offline (serverless‑offline): spawn serverless offline start; pre‑run
  register+openapi; restart child on route surface change; prefix child output.
- inline (default once implemented): in‑process server mapping Node HTTP →
  APIGatewayProxyEvent (v1) → wrapped handler. Build route table from
  app.buildAllServerlessFunctions(); wrapper handles HEAD, negotiation, errors.
  Print route table and resolved port.

Stage & environment in dev:

- Stage default: first stage key in app.stages not named "default"; fallback dev.
- Seed process.env from app.global.params and app.stage.params[stage] so dev
  mirrors provider env semantics.
- For DynamoDB Local: handlers switch to local when `DYNAMODB_LOCAL_ENDPOINT` is present in the environment.

## 6) Register freshness (Serverless plugin) and optional hooks

- Provide a lightweight Serverless v4 plugin
  (@karmaniverous/smoz/serverless‑plugin) that runs `smoz register` before
  package/deploy steps. Keep it small and fail fast.
- Optional pre‑commit recipe (documented, not enforced): run `smoz register`
  when app/functions/\*_ changes and stage updated register._.ts files.
- Continue chaining `register` ahead of scripts that depend on fresh registers:
  - openapi: register && tsx app/config/openapi && prettier
  - package/deploy: register && serverless ...

## 7) Templates — baseline, TypeScript configs, ESLint, placeholders, and dynamodb template

Baseline:

- Single "default" template including:
  - app/config/app.config.ts
  - app/functions/rest/hello/get/{lambda,handler,openapi}.ts
  - app/functions/rest/openapi/get/{lambda,handler,openapi}.ts
  - serverless.ts
  - app/config/openapi.ts and scripts (register/openapi/package/dev)
- Non‑HTTP examples are added via `smoz add` or documented under /examples.

TypeScript configs (two‑tsconfig approach):

- Dev tsconfig (templates/default/tsconfig.json):
  - Maps @karmaniverous/smoz → ../../dist so editors and typed ESLint resolve
    the toolkit without publishing.
- Downstream tsconfig (templates/default/tsconfig.downstream.json) — shipped:
  - `smoz init` renames this to tsconfig.json (writes tsconfig.json.example if a
    tsconfig already exists).
  - Contains no repo‑local path mappings.
- Typed ESLint project (templates/default/tsconfig.eslint.json) — extend‑only:
  - Extends ./tsconfig.json so typed ESLint resolves types consistently.
  - Houses lint‑only tweaks without perturbing the compiler.

Template ESLint:

- A unified ESLint flat config (templates/default/eslint.config.ts) drives typed
  lint for template sources using tseslint with project ['./tsconfig.eslint.json'].

Template typecheck:

- Script discovers templates/\*/tsconfig.json and runs `tsc -p --noEmit`.

Register placeholders policy:

- Templates must typecheck in a clean clone without running CLI steps. Ship a
  single ambient declarations file that declares:
  - '@/app/generated/register.functions'
  - '@/app/generated/register.openapi'
  - '@/app/generated/register.serverless'
- Runtime placeholders are created by `smoz init` in real apps and maintained by
  `smoz register`; templates should not include app/generated placeholders.

DynamoDB template (opt‑in; name: `dynamodb`):

- tables/000/:
  - entityManager.ts — values‑first + schema‑first; imports shared domain Zod (user)
  - table.yml — TableName: `${param:STAGE_NAME}-000`
  - (no transform.ts for 000; identity default; no prior version)
- app/domain/user.ts — authoritative domain Zod schema (borrowed by EM and HTTP)
- app/functions/rest/users/\* endpoints (inline CRUD/search):
  - GET /users — query params per entity‑manager‑demo (beneficiaryId, name, phone, createdFrom/To, updatedFrom/To, sortOrder, sortDesc, pageKeyMap)
  - POST /users — create
  - GET /users/{id} — read
  - PUT /users/{id} — shallow update
  - DELETE /users/{id} — delete
- serverless.ts:
  - resources.Resources:
    - Table000: ${file(./tables/000/table.yml)}
    - Later versions (Table001, …) imported side‑by‑side until decommissioned after migration
- Provider params/env:
  - Params:
    - STAGE_NAME = ${SERVICE_NAME}-${STAGE} (duplicated per stage intentionally; best practice)
    - TABLE_VERSION (public/global)
  - Environment:
    - TABLE_VERSION_DEPLOYED = ${env:TABLE_VERSION_DEPLOYED} (private per env; assumed loaded by a separate secrets step)
    - TABLE_NAME = ${param:STAGE_NAME}-${param:TABLE_VERSION}
    - TABLE_NAME_DEPLOYED = ${param:STAGE_NAME}-${env:TABLE_VERSION_DEPLOYED}
    - DYNAMODB_LOCAL_ENDPOINT (optional; if present, handlers target Local)
- CLI guidance:
  - Teams can configure `plugins.dynamodb.local.start|stop|status` in getdotenv config with native `$DYNAMODB_LOCAL_ENDPOINT`/`$DYNAMODB_LOCAL_PORT` interpolation, or install `@karmaniverous/dynamodb-local` and use the embedded fallback.

Default template (best‑practice seed):

- Add STAGE_NAME param (not consumed yet; used in future Secrets Manager integration).

## 8) Init UX — conflicts, installation, defaults, and manifest handling

Template selection:

- -t/--template accepts a packaged template name ("default", "dynamodb")
  or a filesystem directory path.

Conflict handling (non‑package.json files):

- Interactive: Overwrite, Add example (<file>.example), Skip. Provide “apply to all”.
- Non‑interactive (-y): governed by cliDefaults.init.onConflict (ask|overwrite|example|skip);
  default is "example"; --conflict overrides.

Installation:

- With -y: perform install by default using the detected PM (npm|pnpm|yarn|bun).
  Overrides: --no-install or --install <pm>.
- Without -y: prompt for install; in CI, use -y with an explicit --install.

Defaults file (optional): smoz.config.json may provide:

- cliDefaults.init.onConflict, cliDefaults.init.install, cliDefaults.init.template,
  and cliDefaults.dev.local.

Manifest handling:

- Do not copy the template’s package.json during init.
- Always handle the manifest via an additive merge:
  - Create when missing; otherwise merge dependencies/devDependencies/peerDependencies
    and scripts only when absent; never overwrite existing keys.
- Avoids unnecessary conflict prompts for package.json while keeping behavior predictable.

## 9) Routing, path normalization, and portability

- One function per method/basePath; HEAD is auto‑handled by the middleware
  (do not author duplicate HEAD routes).
- Multiple security contexts via httpContexts (public/private/my); non‑public
  paths receive a context prefix in Serverless and OpenAPI surfaces.
- Normalize all paths to POSIX separators in authored code and generated artifacts.
- Provide small helpers (toPosixPath, dirFromHere) for cross‑platform hygiene.
- Search endpoints should prefer GET with query parameters when appropriate
  (e.g., `/users`), mirroring entity‑manager‑demo conventions.

## 10) Event tokens and HTTP tokens

- The single source of truth for event tokens is baseEventTypeMapSchema
  (rest, http, sqs, ...). Extend it per project needs.
- defaultHttpEventTypeTokens establishes which tokens are treated as HTTP at runtime.
- Step Functions (Lambda Invoke) is a first‑class token:
  - Token: `step`
  - Zod v4 shape: `z.object({ Payload: z.unknown().optional() }).catchall(z.unknown())`
    (use catchall; passthrough is deprecated).

## 11) App‑level function defaults (env keys)

- App.create accepts optional `functionDefaults.fnEnvKeys`.
- Registry merges defaults and per‑function `fnEnvKeys`.
- Provider‑level environment is built from globally exposed keys; per‑function
  env includes only additional keys (excluding globals).

## 12) Types hygiene (reuse public platform types)

- Do not redeclare platform types that exist in public dependencies; import from
  aws‑lambda or toolkit contracts.
- Inline dev server (HTTP):
  - Use APIGatewayProxyEvent (v1), APIGatewayProxyResult, and Context from aws‑lambda.
  - Mapping: Node HTTP → APIGatewayProxyEvent (v1) → wrapped handler; pass the
    resulting envelope through.

## 13) Lint/format and template scalability

- Prettier is the single source of truth for formatting; ESLint defers to Prettier
  and enforces TypeScript/ordering rules.
- Keep imports sorted (per repo tooling) and avoid dead code.
- A unified templates ESLint config enables typed lint for all templates without
  per‑template edits.
- Template typecheck script scales by discovering tsconfig.json under templates/\*.

## 14) Documentation structure and Typedoc ordering

- External docs (docs‑src/\*.md) include front matter (title, sidebar_label, sidebar_position).
- Typedoc ordering in typedoc.json "projectDocuments":
  1. Overview
  2. Why smoz?
  3. Getting started
  4. 10‑minute tour
  5. Middleware
  6. Recipes (index + subpages)
  7. Templates
  8. CLI
  9. Contributing
  10. CHANGELOG.md
- Exclude CLI source symbols (src/cli/\*\*) from API reference; CLI usage is documented in docs‑src/cli.md.
- Cross‑link to the DynamoDB plugin docs for Local orchestration specifics.

## 15) Integration fixture (/app)

Purpose:

- Keep a small in‑tree example app to validate end‑to‑end flows in CI
  (register → OpenAPI → package). Not intended for deployment and not published.

Policy:

- Keep /app on main to avoid bitrot; do not move it to a long‑lived branch.
- Neutral identifiers:
  - service: smoz‑sample
  - domains: api.example.test / api.dev.example.test
  - ARNs: placeholders
- Provide /app/README.md explaining purpose and non‑publish status.
- Ensure repository scripts operate against the fixture without deploy (package only).
- The fixture should reflect the combined feature set once the dynamodb template lands:
  - tables/000 with versioned TableName `${param:STAGE_NAME}-000`
  - Users endpoints using inline CRUD/search with EntityClient and domain Zod
  - Provider env/params for TABLE_VERSION, TABLE_VERSION_DEPLOYED, TABLE_NAME/DEPLOYED, STAGE_NAME
  - IAM permissive for simplicity

## 16) Install guard (operators may forget install)

- Detect and surface likely missing installs (no node_modules/ or common module‑not‑found logs for core dependencies).
- Prompt users to run their package manager’s install rather than adding shims.
- Remove accidental shims after install.

## 17) Logger shape

- Any accepted logger must satisfy ConsoleLogger (console‑compatible).
- Defaults use `console`; middleware and wrappers rely on ConsoleLogger.

## 18) OpenAPI specs (hand‑crafted)

- OpenAPI specs are authored by hand; no automatic derivation from Zod.
- When useful, use `z.any()` as placeholders and refine iteratively.

## 19) Testability of environment config

- Avoid top‑level ESM imports from config paths that complicate `vi.mock()`;
  prefer lazy imports inside functions to keep tests predictable.
- Avoid dynamic type imports.

## 20) DynamoDB integration (versioned tables, dynamic naming, local orchestration, migrations)

Versioned tables & Serverless import:

- Tables are declared per version under `tables/NNN/` (zero‑padded; start at `000`).
- Each version emits a full AWS::DynamoDB::Table resource YAML:
  - `TableName: ${param:STAGE_NAME}-NNN` (dynamic with respect to STAGE_NAME)
- Serverless imports multiple versions side‑by‑side under distinct logical IDs:
  - e.g., `resources.Resources.Table000: ${file(./tables/000/table.yml)}`
- Teams remove older imports only after migrations are proven (coexistence during migration is required).

Dynamic naming & canonical runtime table:

- `STAGE_NAME = ${SERVICE_NAME}-${STAGE}` is a first‑class param duplicated per stage; it may form the basis of many resource names.
- Global/public code version:
  - `TABLE_VERSION` (tracked) — the version the code expects (e.g., "000", "001")
- Private/per‑environment deployed version:
  - `TABLE_VERSION_DEPLOYED` — loaded via a separate secrets process into `.local` before deploy
- Canonical runtime table names:
  - `TABLE_NAME = ${STAGE_NAME}-${TABLE_VERSION}`
  - `TABLE_NAME_DEPLOYED = ${STAGE_NAME}-${TABLE_VERSION_DEPLOYED}`
- Application code targets the single canonical runtime table (TABLE_NAME).
- Post‑deploy migration processes (out of scope for SMOZ) run:
  - `fromVersion = TABLE_VERSION_DEPLOYED`
  - `toVersion = TABLE_VERSION`
  - Source/target tables resolved from the naming convention; identity transform is the default when no transform file is authored.

Local DynamoDB orchestration:

- Primary env:
  - `DYNAMODB_LOCAL_ENDPOINT` — when set, handlers configure EntityClient to target Local; otherwise the AWS SDK defaults to cloud
  - `DYNAMODB_LOCAL_PORT` — optional helper used in configs/commands
- smoz dynamodb local start|stop|status are provided by the plugin with config‑first execution and embedded fallback:
  - Config commands live under `plugins.dynamodb.local.{start|stop|status}` with native env interpolation ($DYNAMODB_LOCAL_ENDPOINT/PORT).
  - Embedded path is available when `@karmaniverous/dynamodb-local` is installed.
  - start waits for readiness; status returns 0 when healthy.

Identity transforms:

- For the initial version (000), no transform file is needed; the identity chain is the default and there is no prior version to migrate.

CRUD/search endpoints:

- HTTP handlers perform CRUD/search inline with EntityClient and borrow response/request schemas from the domain Zod used by EntityManager.
- Search endpoints should use GET and query params (`/users`) and match the entity‑manager‑demo semantics, including round‑trippable pageKeyMap.
