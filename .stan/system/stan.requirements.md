# Project Requirements — @karmaniverous/smoz

When updated: 2025-10-19T00:00:00Z

Purpose

- This document captures durable, repo‑specific requirements for the SMOZ
  toolkit. It is the single source of truth for product/engineering policy.
- Assistant/policy instructions live in .stan/system/stan.project.md.

Contents

- 1. Repository scope and publishing
- 2. Architecture and application model
- 3. HTTP middleware policy (order and behavior)
- 4. Aggregation builders (Serverless + OpenAPI)
- 5. CLI — get-dotenv host, commands (init/add/register/openapi/dev/cmd/batch), flags, and config
- 6. Register freshness (Serverless plugin) and optional hooks
- 7. Templates — baseline, TypeScript configs, ESLint, and placeholders
- 8. Init UX — conflicts, installation, defaults, and manifest handling
- 9. Routing, path normalization, and portability
- 10. Event tokens and HTTP tokens
- 11. App‑level function defaults (env keys)
- 12. Types hygiene (reuse public platform types)
- 13. Lint/format and template scalability
- 14. Documentation structure and Typedoc ordering
- 15. Integration fixture (/app)
- 16. Install guard (operators may forget install)
- 17. Logger shape
- 18. OpenAPI specs (hand‑crafted; Zod v4 posture)
- 19. Testability of environment config
- 20. Environment resolution via get-dotenv (host integration)
  - Layering model, validation, diagnostics, spawn env, and AWS plugin
  - Stage resolution precedence

---

## 1) Repository scope and publishing

- Publish only the toolkit and templates to npm:
  - files: ["dist", "templates"]
  - The /app fixture is not published; it is for CI validation only.
- Toolkit surface:
  - Runtime wrapper and HTTP middleware building blocks.
  - Serverless/OpenAPI aggregators and helpers.
  - Configuration typing and utilities (e.g., path helpers).
  - CLI implemented as a get-dotenv host (see §5, §20).
- Build & publish policy (bundling & path aliases):
  - Published outputs (ESM/CJS/DTS) MUST NOT contain project‑local TS alias
    specifiers (e.g., `@/src/...`). The Rollup build resolves `@/` → `src/`
    via @rollup/plugin‑alias so downstream runtimes never see alias specifiers.

## 2) Architecture and application model

Schema‑first App with a registry:

- App.create(config) captures:
  - Global/stage parameter schemas and env exposure nodes.
  - Event type map schema and runtime HTTP tokens.
  - Stage artifacts: provider environment, params, and a per‑function env builder.
  - Implementation‑wide Serverless defaults.
- Author endpoints as small modules:
  - lambda.ts (register + schemas)
  - handler.ts (business logic)
  - openapi.ts (operation)
  - serverless.ts (non‑HTTP extras)
- Registry APIs per function: handler(business), openapi(baseOperation), serverless(extras).
- Side‑effect registers (generated by CLI):
  - app/generated/register.functions.ts — imports all lambda.ts
  - app/generated/register.openapi.ts — imports all openapi.ts
  - app/generated/register.serverless.ts — imports non‑HTTP serverless.ts

## 3) HTTP middleware policy (order and behavior)

Canonical order (must remain stable):

1. HEAD short‑circuit (returns 200 {} immediately)
2. Header normalizer
3. APIGateway v1 event normalizer
4. Content negotiation (JSON + vendor +json)
5. JSON body parser (no 415 on missing content type)
6. Zod validation (before handler; after handler)
7. Error exposure (maps validation failures to 400)
8. http‑error‑handler (uses ConsoleLogger)
9. CORS (credentials on; preserves computed origin)
10. Preferred media defaults across phases
11. Response shaper (enforce Content‑Type; ensure string body)
12. Response serializer (JSON + vendor +json)

Acceptance:

- HEAD is finalized to 200 {} and is not post‑validated.
- Shaped/string bodies pass transparently; others are shaped.
- Zod validation failures map to 400; other errors are exposed per handler.

## 4) Aggregation builders

- buildAllServerlessFunctions():
  - For HTTP tokens: derive method/basePath/contexts (or infer from paths)
    and produce handler strings. Provider env comes from app; per‑function env
    is built from explicit fnEnvKeys excluding globally exposed keys.
  - For non‑HTTP tokens: pass through extras supplied via serverless(extras).
- buildAllOpenApiPaths():
  - Merge path items for each configured context. operationId is composed as
    `${segments}_${method}` with a context prefix for non‑public routes.

## 5) CLI — get-dotenv host, commands, flags, and config

CLI as a get-dotenv host (no Commander fallback):

- smoz bin instantiates a GetDotenvCli host with branding (“smoz vX.Y.Z”).
- Global host options (documented in smoz help):
  - -e, --env <overlay...> select dotenv overlays
  - --strict fail on validation errors (warn by default)
  - --trace print full layered trace (redacted)
  - -V, --verbose verbose trace with masked values + entropy notes
- Commands (all installed in the host):
  - init: scaffold app (templates; conflicts/install per §8)
  - add: scaffold endpoint skeletons
  - register: generate side-effect registers
  - openapi: run the app’s OpenAPI build
  - dev: watch loop (register/openapi + inline/offline)
  - cmd: execute an arbitrary command with the resolved env (get-dotenv cmd plugin)
    - Cross-platform shell handling per get-dotenv (argv-aware; /bin/bash on POSIX; powershell.exe on Windows by default; overridable).
    - Quoting guidance: recommend single-quoted strings for POSIX and PowerShell when referencing $FOO to avoid outer-shell expansion; in npm scripts, prefer `"smoz cmd -- 'echo $FOO'"` or `"smoz -c echo $FOO"` depending on style; see §20.
  - batch: run multiple commands (get-dotenv batch plugin)
    - Concurrency: `--concurrency <n>` (default 1). Buffered capture with end-of-run summary. Optional `--live` for prefixed interleaved streaming.
    - Per-script hints (when used with getdotenv.config scripts surfaces): `parallel?: boolean`, `concurrency?: number`.
- Configuration files for env and defaults:
  - getdotenv.config.{json,yaml,yml,js,ts} at repo root; local variant getdotenv.config.local.{…} for private values.
  - JSON/YAML = pure data (no dynamic). JS/TS may export:
    - dynamic (functions for computed keys),
    - schema (Zod v4 object),
    - plugins section (see §20),
    - diagnostics config (redaction/entropy knobs).
- The host builds a single ctx once per invocation (pre-subcommand), resolving env and validation (see §20). Subcommands/plugins consume ctx; they do not re-resolve env.

## 6) Register freshness (Serverless plugin) and optional hooks

- Provide a lightweight Serverless v4 plugin
  (@karmaniverous/smoz/serverless‑plugin) that runs `smoz register` before
  package/deploy steps. Keep it small and fail fast.
- Optional pre‑commit recipe (documented, not enforced): run `smoz register`
  when app/functions/\*_ changes and stage updated register._.ts files.
- Continue chaining `register` ahead of scripts that depend on fresh registers:
  - openapi: register && tsx app/config/openapi && prettier
  - package/deploy: register && serverless ...

## 7) Templates — baseline, TypeScript configs, ESLint, and placeholders

Baseline:

- Single "default" template including:
  - app/config/app.config.ts
  - app/functions/rest/hello/get/{lambda,handler,openapi}.ts
  - app/functions/rest/openapi/get/{lambda,handler,openapi}.ts
  - serverless.ts
  - app/config/openapi.ts and scripts (register/openapi/package/dev)

TypeScript configs (two‑tsconfig approach):

- Dev tsconfig (templates/default/tsconfig.json):
  - Maps @karmaniverous/smoz → ../../dist so editors and typed ESLint resolve
    the toolkit without publishing.
- Downstream tsconfig (templates/default/tsconfig.downstream.json) — shipped:
  - `smoz init` renames this to tsconfig.json (writes tsconfig.json.example if a
    tsconfig already exists).
  - Contains no repo‑local path mappings.
- Typed ESLint project (templates/default/tsconfig.eslint.json) — extend‑only:
  - Extends ./tsconfig.json so typed ESLint resolves types consistently.
  - Houses lint‑only tweaks without perturbing the compiler.

Template ESLint:

- A unified ESLint flat config (templates/default/eslint.config.ts) drives typed
  lint for template sources using tseslint with project ['./tsconfig.eslint.json'].

Template typecheck:

- Script discovers templates/\*/tsconfig.json and runs `tsc -p --noEmit`.

Register placeholders policy:

- Templates must typecheck in a clean clone without running CLI steps. Ship a
  single ambient declarations file that declares:
  - '@/app/generated/register.functions'
  - '@/app/generated/register.openapi'
  - '@/app/generated/register.serverless'
- Runtime placeholders are created by `smoz init` in real apps and maintained by
  `smoz register`; templates should not include app/generated artifacts.

## 8) Init UX — conflicts, installation, defaults, and manifest handling

Template selection:

- -t/--template accepts a packaged template name ("default")
  or a filesystem directory path.

Conflict handling (non‑package.json files):

- Interactive: Overwrite, Add example (<file>.example), Skip. Provide “apply to all”.
- Non‑interactive (-y): governed by cliDefaults.init.onConflict (ask|overwrite|example|skip);
  default is "example"; --conflict overrides.

Installation:

- With -y: perform install by default using the detected PM (npm|pnpm|yarn|bun).
  Overrides: --no-install or --install <pm>.
- Without -y: prompt for install; in CI, use -y with an explicit --install.

Defaults file (optional): smoz.config.json may provide:

- cliDefaults.init.onConflict, cliDefaults.init.install, cliDefaults.init.template,
  and cliDefaults.dev.local.

Manifest handling:

- Do not copy the template’s package.json during init.
- Always handle the manifest via an additive merge:
  - Create when missing; otherwise merge dependencies/devDependencies/peerDependencies
    and scripts only when absent; never overwrite existing keys.
- Avoids unnecessary conflict prompts for package.json while keeping behavior predictable.

## 9) Routing, path normalization, and portability

- One function per method/basePath; HEAD is auto‑handled by the middleware
  (do not author duplicate HEAD routes).
- Multiple security contexts via httpContexts (public/private/my); non‑public
  paths receive a context prefix in Serverless and OpenAPI surfaces.
- Normalize all paths to POSIX separators in authored code and generated artifacts.
- Provide small helpers (toPosixPath, dirFromHere) for cross‑platform hygiene.

## 10) Event tokens and HTTP tokens

- The single source of truth for event tokens is baseEventTypeMapSchema
  (rest, http, sqs, ...). Extend it per project needs.
- defaultHttpEventTypeTokens establishes which tokens are treated as HTTP at runtime.
- Step Functions (Lambda Invoke) is a first‑class token:
  - Token: `step`
  - Zod v4 shape: `z.object({ Payload: z.unknown().optional() }).catchall(z.unknown())`
    (use catchall; Zod v4 deprecates passthrough).
  - Prefer `z.unknown()` over `z.any()` for unknown payloads.

## 11) App‑level function defaults (env keys)

- App.create accepts optional `functionDefaults.fnEnvKeys`.
- Registry merges defaults and per‑function `fnEnvKeys`.
- Provider‑level environment is built from globally exposed keys; per‑function
  env includes only the additional keys (excluding globals).

## 12) Types hygiene (reuse public platform types)

- Do not redeclare platform types that exist in public dependencies; import from
  aws‑lambda or toolkit contracts.
- Inline dev server (HTTP):
  - Use APIGatewayProxyEvent (v1), APIGatewayProxyResult, and Context from aws‑lambda.
  - Mapping: Node HTTP → APIGatewayProxyEvent (v1) → wrapped handler; pass the
    resulting envelope through.

## 13) Lint/format and template scalability

- Prettier is the single source of truth for formatting; ESLint defers to Prettier
  and enforces TypeScript/ordering rules.
- Keep imports sorted (simple‑import‑sort).
- A unified templates ESLint config enables typed lint for all templates without
  per‑template edits.
- Template typecheck script scales by discovering tsconfig.json under templates/\*.

## 14) Documentation structure and Typedoc ordering

- External docs (docs‑src/\*.md) include front matter (title, sidebar_label, sidebar_position).
- Typedoc ordering in typedoc.json "projectDocuments":
  1. Overview
  2. Why smoz?
  3. Getting started
  4. 10‑minute tour
  5. Middleware
  6. Recipes (index + subpages)
  7. Templates
  8. CLI
  9. Contributing
  10. CHANGELOG.md
- Exclude CLI source symbols (src/cli/\*\*) from API reference; CLI usage is documented in docs‑src/cli.md.

## 15) Integration fixture (/app)

Purpose:

- Keep a small in‑tree example app to validate end‑to‑end flows in CI
  (register → OpenAPI → package). Not intended for deployment and not published.

Policy:

- Keep /app on main to avoid bitrot; do not move it to a long‑lived branch.
- Neutral identifiers:
  - service: smoz‑sample
  - domains: api.example.test / api.dev.example.test
  - ARNs: placeholders
- Provide /app/README.md explaining purpose and non‑publish status.
- Ensure repository scripts operate against the fixture without deploy (package only).
- Planned: remove STAGE from stage.params/schema in fixture/template; rely on provider.stage injection (see §20).

## 16) Install guard (operators may forget install)

- Detect and surface likely missing installs (no node_modules/ or common module‑not‑found logs for core dependencies).
- Prompt users to run their package manager’s install rather than adding shims.
- Remove accidental shims after install.

## 17) Logger shape

- Any accepted logger must satisfy ConsoleLogger (console‑compatible).
- Defaults use `console`; middleware and wrappers rely on ConsoleLogger.

## 18) OpenAPI specs (hand‑crafted; Zod v4 posture)

- OpenAPI specs are authored by hand; no automatic derivation from Zod.
- For unknown payloads, prefer `z.unknown()` (not `z.any()`).
- For objects that must tolerate additional properties, use `.catchall(z.unknown())` (avoid deprecated passthrough).
- When useful, use precise object schemas instead of broad unknowns; placeholders should be tightened over time.

## 19) Testability of environment config

- Avoid top‑level ESM imports from config paths that complicate `vi.mock()`;
  prefer lazy imports inside functions to keep tests predictable.
- Avoid dynamic type imports.

## 20) Environment resolution via get-dotenv (host integration)

Host responsibilities (smoz is a get-dotenv host):

- One ctx per invocation, resolved before plugins run.
- Layered processing model (ordered; per‑layer interpolation of string leaves):
  1. Dotenv overlays selected by -e (with expansion inside files).
  2. Key aliases (optional; copy defined keys when targets are unset).
  3. Config data overlays (public "vars" and per-env "envVars") with interpolation against the current env.
  4. Dynamic (JS/TS) computed values; functions run with the current env.
  5. Plugin defaults from config with interpolation (e.g., plugins.smoz.stage: "${ENV:dev}").
  6. CLI options override plugin defaults (normal precedence).
  7. Validation (Zod schema and/or requiredKeys); warn by default; "--strict" to fail.
  8. Context built (ctx.dotenv, ctx.options, ctx.dotenvFiles, trace artifacts) and passed to plugins/commands.
- Validation policy:
  - Zod v4 object schema (JS/TS config) or requiredKeys (JSON/YAML).
  - Warn by default; fail when --strict is set.
  - No deprecated Zod APIs (prefer z.unknown over z.any; use .catchall for extras).
- Diagnostics and redaction:
  - --trace prints layer order and per-key origins with masked values.
  - -V/--verbose enables a friendlier trace subset and entropy warnings.
  - Redaction: mask secret-like keys (defaults configurable). Presentation-only.
  - Entropy warnings: gated by min length and printable ASCII; threshold in bits/char; once per key per run; configurable via diagnostics.
- Spawn env normalization (children):
  - Use get-dotenv’s spawn-env helper for tsx inline, serverless offline/package, prettier/typedoc, etc.
  - Behavior: drop undefined; dedupe Windows env keys case-insensitively (last wins, casing preserved); HOME fallback from USERPROFILE; TMPDIR/TEMP/TMP normalization.
  - Always pass ctx.dotenv to spawn-env so children see the resolved environment.
- AWS base plugin (installed by default; inert unless configured):
  - Inputs from ctx.dotenv and plugins.aws config:
    - Profile precedence: plugins.aws.profile > AWS_LOCAL_PROFILE > AWS_PROFILE.
    - Region precedence: plugins.aws.region > AWS_REGION > “aws configure get region --profile …” > plugins.aws.defaultRegion.
  - Strategy: cli-export (modern AWS CLI) with optional `aws sso login` once when loginOnDemand=true and export just failed (SSO profile).
  - Publishing:
    - setEnv (default true): write AWS\_\* and AWS_REGION into process.env.
    - addCtx (default true): mirror `{ profile, region, credentials }` into ctx.plugins.aws.
- Stage resolution (dev) — explicit precedence:
  1. --stage (CLI wins).
  2. plugins.smoz.stage from get-dotenv config (interpolated; e.g., "${ENV:dev}").
  3. process.env.STAGE (from overlays/aliases/plugins).
  4. Default inference: first non-"default" stage; else "dev".
  - Do not bind -e to stage implicitly. Teams can opt-in via plugins.smoz.stage or by aliasing ENV→STAGE when unset.
  - Serverless packaging: inject STAGE from provider.stage/provider.environment instead of carrying it in stage.params (fixture/template follow-on).
- Exposed utility commands (get-dotenv plugins):
  - cmd:
    - Execute a command with the composed env; default shell selection is OS-aware (no shell, default shell, or explicit shell string).
    - Quoting guidance: use single quotes to prevent outer-shell expansion (POSIX & PowerShell). In npm scripts, pass flags to smoz, not the child, by placing them before `--`.
  - batch:
    - Concurrency `--concurrency <n>` (default 1), optional `--live` streaming, buffered capture with end-of-run summary.
    - Dedicate logs per job under a stable temp/build area if configured by get-dotenv; smoz does not alter the batch plugin’s defaults.

Implementation note (release posture):

- The get-dotenv host replaces the previous Commander-based CLI in one release (no staging/fallback). All smoz commands/flags remain, now with additional cmd and batch commands available.
